#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""Locate and Play

Description:
- A quick wrapper to make playing songs via the local command quick and easy.
- Accepts multiple space- and/or comma-separated choices after presenting the
  results.
- Can enqueue or enqueue and play.
- Can show full paths or just filenames.
- Will behave in a sane fashion when asked to enqueue and play multiple files.
- Can randomly select a given number of tracks from a folder tree.

Note:
- If you decide that you want to enqueue after you see the results and you
  forgot to pass in -q on the command-line, just throw q into your result
  string. It doesn't matter whether it's on it's own or as a prefix or suffix
  to another entry.

--snip--

TODO:
 - Still needs more refactoring.
 - Decide how to expose filtering options from locate.
 - Complete the list of extensions for ModPlug and UADE (3rd-party)
 - Support an "all" keyword and an alternative to Ctrl+C for cancel. (maybe 0)
 - Clean up the code
 - Allow non-file:// URLs.
"""

__appname__ = "Locate and Play"
__author__ = "Stephan Sokolow (deitarion/SSokolow)"
__version__ = "1.1"
__license__ = "GNU GPL 2 or later"

#TODO: Redesign this to support ack-like command-line filter options
ADLIB_EXTS = ['.a2m', '.adl', '.amd', '.bam', '.cff', '.cmf', '.d00', '.dfm',
              '.dmo', '.dro', '.dtm', '.hsc', '.hsp', '.jbm', '.ksm', '.laa',
              '.lds', '.mad', '.mkj', '.msc', '.mtk', '.rad', '.raw', '.rix',
              '.rol', '.sat', '.sa2', '.sci', '.sng', '.imf', '.wlf', '.xad',
              '.xsm', '.m', '.adlib']

CONSOLE_EXTS = ['.adx', '.gbs', '.gym', '.hes', '.kss', '.nsf', '.nsfe', '.ay',
                '.psf', '.sap', '.sid', '.spc', '.vgm', '.vgz', '.vtx', '.ym',
                '.minipsf']

MIDI_EXTS     = ['.mid', '.rmi', '.midi']
MODULE_EXTS   = [',mod', '.s3m', '.stm', '.xm', '.it']
PLAYLIST_EXTS = ['.cue', '.m3u', '.pls', '.xspf']
VIDEO_FILES   = ['.avi', '.flv', '.m4v', '.mov', '.mp4', '.webm']
WAVEFORM_EXTS = ['.aac', '.ac3', '.aif', '.aiff', '.ape', '.au', '.flac',
                 '.m4a', '.mp2', '.mp3', '.mpc', '.ogg', '.shn', '.snd',
                 '.tta', '.voc', '.wav', '.wma', '.wv']

# Edit these lines to choose the kind of files to be filtered for.
# By default, playlist extensions are excluded.
OK_EXTS = (WAVEFORM_EXTS + MODULE_EXTS + CONSOLE_EXTS + MIDI_EXTS +
           ADLIB_EXTS    + VIDEO_FILES)
# If you want true format filtering, YOU write the mimetype cache.

# Blacklist used for gather_random()
BLACKLISTED_EXTS = [
    '.m3u', '.pls', '.xspf'     # Playlists (just enqueue directly)
    '.jpg', '.jpeg', '.png', '.gif', '.bmp',  # Images (eg. Cover Art)
    '.txt', '.html', '.htm',    # Not media
    '.sid',                     # Capable of looping infinitely
    '.mid', '.midi', '.rmi',    # Require the keyboard to be turned on manually
]
# Note: SID is actually blacklisted for two reasons:
#  1. I have the entire HVSC and I don't want that to weight the randomization
#     in favor of SIDs.
#  2. All the SIDs I've encountered loop infinitely and I want my playlist to
#     stop after a predictable interval.

USE_PAGER = False   # Should we page output if it's more than a screenful?
DEFAULT_RAND_COUNT = 10

locate_command = ['locate', '-i']

# ========== Configuration Ends ==========

import fnmatch, logging, os, random, subprocess, sys
log = logging.getLogger(__name__)

# Use readline if available but don't depend on it
try:
    import readline
    readline  # Shut PyFlakes up
except ImportError:
    pass

try:
    import dbus
    from dbus.exceptions import DBusException
    import xml.etree.cElementTree as ET
except ImportError:
    # Let the exception handler wrapping the MPRISAdder() call handle it
    DBusException = Exception
    pass

class MPRISAdder(object):
    """Convenience wrapper for accessing MPRIS AddTrack via D-Bus.
    @todo: Blog about the tasks within this. I had to piece it together.
        - Dynamically retrieving a suitable MPRIS interface.
        - Testing for method existence
    """
    ifname = 'org.freedesktop.MediaPlayer'

    def __init__(self, bus=None):
        """
        @todo: Support a configurable preference for a specific player
        @todo: Make sure I properly support both MPRIS1 and MPRIS2.
        """
        self.bus = bus or dbus.Bus(dbus.Bus.TYPE_SESSION)

        for name in self.get_player_names():
            iface = self._get_dbus_if(name, '/TrackList', self.ifname)
            if 'AddTrack' in self.get_method_names(iface):
                self.iface = iface
                break
        else:
            raise DBusException("No media player with MPRIS AddTrack found")

    def _get_dbus_if(self, name, path, interface):
        obj = self.bus.get_object(name, path)
        return dbus.Interface(obj, dbus_interface=interface)

    def get_player_names(self):
        """Find all D-Bus names for MPRIS-compatible players"""
        ispect_if = self._get_dbus_if(
                'org.freedesktop.DBus', '/', 'org.freedesktop.DBus')
        return [x for x in ispect_if.ListNames() if x.startswith('org.mpris.')]

    def get_method_names(self, interface):
        """Get all method names within C{self.ifname} on the given interface.

        @todo: Extract ifname from the passed-in interface object.
        """
        dom = ET.fromstring(interface.Introspect(
                dbus_interface='org.freedesktop.DBus.Introspectable'))
        funcs = dom.findall(".//interface[@name='" + self.ifname + "']/method")
        return [x.get('name') for x in funcs]

    def add_tracks(self, paths, play=False):
        """Add the given tracks to the player's playlist and, C{if play=True},
        start the first one playing.
        """
        for path in paths:
            if not os.path.exists(path):
                log.error("File does not exist: %s", path)

            if isinstance(path, str):
                path = path.decode(sys.getfilesystemencoding())
            file_url = 'file://' + path

            self.iface.AddTrack(file_url, play)
            play = False  # Only start the first one playing

def gather_random(roots, wanted_count):
    """Use C{os.walk} to choose C{wanted_count} files from C{roots}.

    @type roots: C{list} of C{basestring}
    """
    choices = []
    for root in roots:
        for fldr, dirs, files in os.walk(root):
            choices.extend(os.path.join(fldr, x) for x in files
                    if not os.path.splitext(x)[1].lower() in BLACKLISTED_EXTS)

    chosen = []
    for i in range(0, opts.wanted_count):
        # We don't want duplicates
        chosen.append(choices.pop(random.randrange(0, len(choices))))

    return chosen

#TODO: Refactor and reuse elsewhere
def get_results(query, locate_cmd=locate_command):
    """Retrieve matches for C{query} in L{OK_EXTS} using L{locate_command}."""
    if isinstance(query, basestring):
        query = [query]

    results, cmd = [], locate_cmd + query
    for line in subprocess.Popen(cmd, stdout=subprocess.PIPE).stdout:
        result = line.strip()
        if os.path.splitext(result)[1] in OK_EXTS:
            results.append(result)
    results.sort()
    return results

#TODO: Document and, if necessary, refactor
def parseChoice(inString):
    try:
        return [int(inString)]
    except ValueError:
        choices = []
        for x in inString.replace(',', ' ').split():
            try:
                choices.append(int(x))
            except ValueError:
                try:
                    first, last = [int(y) for y in x.split(':', 1)]
                    choices.extend(range(first, last + 1))
                except ValueError:
                    print("Not an integer or range: %s" % x)
        return choices

#TODO: Document and, if necessary, refactor
def choose(results, strip_path):
        # Draw the menu
        for pos, val in enumerate(results):
            val = strip_path and os.path.basename(val) or val
            print("%3d) %s" % (pos + 1, val))

        choices = raw_input("Choice(s) (Ctrl+C to cancel): ")

        if 'q' in choices.lower():
            opts.enqueue = True  # FIXME: Remove this side-effect.
            choices = choices.replace('q', '')  # FIXME: This will distort
                 # the "Not an integer" message for values containing "q".

        output = []
        for index in parseChoice(choices):
            if index > 0 and index <= len(results):
                output.append(results[index - 1])
            else:
                print("Invalid result index: %d" % index)

        return output

#TODO: Split this up more
if __name__ == '__main__':
    cmd = os.path.split(sys.argv[0])[1]
    aTy = (cmd.lower() in ('ap', 'aq')) and '<path> ...' or '<keyword> ...'

    from optparse import OptionParser
    op = OptionParser(version="%%prog v%s" % __version__,
        usage="%prog [options] " + aTy,
        description=__doc__.replace('\r\n', '\n').split('\n--snip--\n')[0])

    # TODO: Reconcile all these. Maybe make all input via options and then
    #       use configurable personalities to map positional arguments to
    #       options.
    op.add_option("-0", "--print0", action="store_true", dest="print_null",
            default=False, help="Display the list of results, separated by "
                                "NULL characters. (good for `xargs -0`)")
    op.add_option("-e", "--exec", action="store", dest="exe_cmd",
        default=None, help="Use this command to enqueue/play rather than "
                           "the default.")
    op.add_option("-l", "--locate", action="store_true", dest="locate",
            default=(cmd.lower() in ('lap', 'laq')),
            help="Treat the arguments as search keywords rather than "
                 "paths. (default if called as 'lap' or 'laq')")
    op.add_option("-n", "--song-count", action="store", type=int,
        dest="wanted_count", default=DEFAULT_RAND_COUNT, metavar="NUM",
        help="Request that NUM randomly-chosen songs be picked rather than"
             " just one.")
    op.add_option("-p", "--print", action="store_true", dest="print_nl",
            default=False, help="Display the list of results, one per line.")
    op.add_option("-P", "--show_path", action="store_true",
            dest="show_path", default=False,
            help="Show the full path to each result.")
    op.add_option('-q', '--quiet', action="count", dest="quiet",
        default=0, help="Decreased verbosity. Use twice for extra effect")
    op.add_option("-Q", "--enqueue", action="store_true", dest="enqueue",
            default=(cmd.lower() in ('aq', 'laq', 'raq')),
            help="Don't start the song playing after enqueueing it. "
                 "(default if called as 'aq' or 'laq')")
    op.add_option("-r", "--random", action="store_true", dest="random",
            default=(cmd.lower() in ('rap', 'raq')),
            help="Select X entries at random from the provided paths. "
                 "(default if called as 'rap' or 'raq')")
    op.add_option('-v', '--verbose', action="count", dest="verbose",
        default=2, help="Increased verbosity. Use twice for extra effect")

    # Allow pre-formatted descriptions
    op.formatter.format_description = lambda description: description

    (opts, args) = op.parse_args()

    # Set up clean logging to stderr
    log_levels = [logging.CRITICAL, logging.ERROR, logging.WARNING,
                  logging.INFO, logging.DEBUG]
    opts.verbose = min(opts.verbose - opts.quiet, len(log_levels) - 1)
    opts.verbose = max(opts.verbose, 0)
    logging.basicConfig(level=log_levels[opts.verbose],
                        format='%(levelname)s: %(message)s')

    # Branch for --exec, MPRIS, or fallback to print
    if opts.exe_cmd:
        add_func = lambda paths, play: subprocess.call([opts.exe_cmd] + paths)
    else:
        try:
            add_func = MPRISAdder().add_tracks
        except (NameError, DBusException):
            print("Cannot connect to D-Bus session bus. Assuming --print.")
            add_func = lambda paths, play: None
            opts.print_nl = True

    if not args:
        #TODO: Do I really want this case to require Python 2.7?
        args.append(subprocess.check_output(
            ['xdg-user-dir', 'MUSIC']).strip())

    # If opts.locate, resolve args using `locate` first.
    if opts.locate:
        # Implement implicit AND for locate (default is implicit OR)
        results = (len(args) > 0) and get_results(args.pop(0)) or []
        for kw in args:
            results = [x for x in results
                    #TODO: Implement locate's "only *%s* if no globbing chars"
                    if fnmatch.fnmatch(x.lower(), '*%s*' % kw.lower())]
    else:
        results = args

    # TODO: Decide whether to support locate without chooser
    if opts.random:
        results = gather_random(args, opts.wanted_count)
    elif opts.locate and not (opts.print_nl or opts.print_null):
        try:
            results = choose(results, not opts.show_path)
        except KeyboardInterrupt:
            results = []
    else:
        results = args

    # Feed the results to the player
    if opts.print_null:
        print('\0'.join(results))
    elif opts.print_nl:
        print('\n'.join(results))
    elif results:
        add_func(results, not opts.enqueue)
    else:
        print("No Results")
